{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"10-13leetcode","text":"公平的糖果棒交换12345678910111213141516171819202122232425262728class Solution { public: vector&lt;int&gt; fairCandySwap(vector&lt;int&gt;&amp; aliceSizes, vector&lt;int&gt;&amp; bobSizes) { int n1=aliceSizes.size(),n2=bobSizes.size(),sum1=0,sum2=0; vector&lt;int&gt; c; for(int i=0;i&lt;n1;i++){ sum1+=aliceSizes[i]; } for(int i=0;i&lt;n2;i++){ sum2+=bobSizes[i]; } sort(aliceSizes.begin(),aliceSizes.end()); sort(bobSizes.begin(),bobSizes.end()); int temp=sum1-(sum1+sum2)/2,i=0,j=0; while(i&lt;n1&amp;&amp;j&lt;n2){ if(aliceSizes[i]-bobSizes[j]==temp){ c.push_back(aliceSizes[i]); c.push_back(bobSizes[j]); break; }else if(aliceSizes[i]-bobSizes[j]&lt;temp){ i++; }else{ j++; } } return c; }}; 矩阵中战斗力最弱的 K 行123456789101112131415161718192021222324252627282930class Solution { static bool compare(pair&lt;int,int&gt; p1,pair&lt;int,int&gt; p2){ if(p1.second!=p2.second){ return p1.second&lt;p2.second; }else{ return p1.first&lt;p2.first; } }public: vector&lt;int&gt; kWeakestRows(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { int m=mat.size(),n=mat[0].size(); vector&lt;pair&lt;int,int&gt;&gt; v; for(int i=0;i&lt;m;i++){ int sum=0; for(int j=0;j&lt;n;j++){ if(mat[i][j]==1){ sum++; } } v.push_back(make_pair(i,sum)); sum=0; } sort(v.begin(),v.end(),compare); vector&lt;int&gt; v2; for(int i=0;i&lt;k;i++){ v2.push_back(v[i].first); } return v2; }};","link":"/2021/10/13/10-13leetcode/"},{"title":"10-5动规","text":"Leetcode传递信息这题乍看之下和pta出租游艇很像，其实不然。主要是多了个k轮传递的限制 代码如下，时间复杂度100左右 123456789101112131415161718192021222324252627282930313233343536class Solution { int m[100][100]; int a[100][100];public: int numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) { for(int i=0;i&lt;relation.size();i++){ a[relation[i][0]][relation[i][1]]=1; } for(int j=1;j&lt;=k;j++){ if(j==1){ for(int r=0;r&lt;n;r++){ if(a[0][r]&gt;0){ m[r][j]=1; } } }else{ for(int p=0;p&lt;n;p++){ if(m[p][j-1]&gt;0){ for(int r=0;r&lt;n;r++){ if(a[p][r]&gt;0){ if(m[r][j]==0){ m[r][j]=m[p][j-1]; }else{ m[r][j]+=m[p][j-1]; } } } } } } } return m[n-1][k]; }}; pta出租游艇长江游艇俱乐部在长江上设置了n个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为r(i,j),1&lt;=i&lt;j&lt;=n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n所需的最少租金。 第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的第1到第n-1 行，第i行表示第i站到第i+1站,第i+2站, … , 第n站的租金。 12335 157 相较于上题，这题用一维数组存储值就好了，m[3]就遍历1、2，用m[1]+1到3的钱，m[2]+2到3的钱，选小的那个。自底向上算 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int a[2000][2000];int m[2000];int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++){ for(int j=i+1;j&lt;=n;j++){ cin&gt;&gt;a[i][j]; } } for(int i=2;i&lt;=n;i++){ m[i]=INT_MAX; int u=0; for(int k=1;k&lt;i;k++){ if((a[k][i]&gt;0&amp;&amp;m[k]&gt;0&amp;&amp;k&gt;1)||(k==1&amp;&amp;a[k][i]&gt;0)){ u=m[k]+a[k][i]; if(u&lt;m[i]){ m[i]=u; } } } if(u==0){ m[i]=0; } } cout&lt;&lt;m[n]; } pta矩阵链动态规划有两个特点：最优子结构和重叠子问题。这道题的最优子结构是，要寻找矩阵i到j的最小乘法次数，可以在i~j中找到一个k，左边矩阵i到k的已经是一个最优序列，右边k+1到j也是一个最优序列，两边的乘法次数之和加上两个子问题的乘法次数(pi * pk * pj)就是i到j的最优解。而i到k，k+1到j也可以用递归算法求得。$$m[i][j]= \\begin{cases} 0, &amp; \\text{if $i$ =$j$}\\ \\min \\limits_ {i&lt;=k&lt;j}{m[i][k]+m[k+1][j]+pipkpj} &amp; \\text{if $i$ &lt; $j$} \\end{cases}$$ 遍历k便得 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[1000];int m[1000][1000];int main(){ cin&gt;&gt;n; for(int i=0;i&lt;=n;i++){ cin&gt;&gt;a[i]; } for(int i=0;i&lt;=n;i++){ m[i][i]=0; } for(int i=n;i&gt;=1;i--){ for(int j=i+1;j&lt;=n;j++){ if(i&lt;j){ m[i][j]=m[i][i]+m[i+1][j]+a[i-1]*a[i]*a[j]; for(int k=i;k&lt;j;k++){ m[i][j]=min(m[i][j],m[i][k]+m[k+1][j]+a[i-1]*a[j]*a[k]); } } } } cout&lt;&lt;m[1][n];} leetcode连续子数组的最大和123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 这道题碰到很多次了，开局把max设为无穷小，u=0，遍历数组，u+=nums[i],如果u比max大，赋值。如果u&lt;0,u=0","link":"/2021/10/05/10-5%E5%8A%A8%E8%A7%84/"},{"title":"9.30关于排序和分治之题","text":"leetcode算法面试题排序与索引最大数把数字转化为字符串，把两个字符串拼接起来，用字符串来进行比较和排序 摆动排序用快排排好后，逆序穿插，把第一大，第二大插到数组第1位，第3位，插到末尾就把剩下逆序插到第0位，第2位，保证摆动。至于为什么这样可以保证搞不懂。 寻找重复数12345给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。 忽略了题目的一个条件，所有数都在1到n之间。所以二分法查询的不是位置，而是1-n的数。比这个数小的，不能大于这个数，因为要没有重复。如果大过了，就证明在0-这个数之间有数重复，所以在这个区间上找。如果没有重复的话，就在n-len这个区间上找。 如果寻找的是不重复数，可以直接用位运算，一个数与0异或等于它本身，两个相同数异或等于0。 进阶： 12345给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。找到所有出现两次的元素。你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 重复元素不止一个，而且在O(n)复杂度。 技巧：遍历数组，元素值对应位置乘-1，如果一个元素出现了两次，它对应的位置已经乘了一次-1，如果&lt;0，则放入结果。 寻找峰值看不透问题的本质，直接用这个数是否大于左边，是否大于右边来算，用二分法不能判断最大数在哪个区间，只能左边区间和右边区间同样递归，时间复杂度反而是指数了，而且边界条件根本判断不了。其实普通的二分法，要求最大数，只要右边这个数不能大于它就行了。大于它的话说明还有数比它大，所以右边区间一定有最大数，不用管左边区间有没有最大数。否则这个数也许是最大数，就在左边找。真的为自己的智商堪忧。 算法实验课两个有序序列的中位数(分治)时间复杂度为log(n)，首先基本思想因为两个数组已经排好，而且求中位数，所以比较两个数组的中间元素，要是相等，则因为都是中位数，这两个数一定挨在一起，则整体的中位数必定是这个数，所以直接返回这个数。具体看下图 所以基本思路就是这样。为了保证递归的时候两个子数组长度相等，对mid可以这样处理 12mid1=(la+ua)/2;mid2=(lb+ub+1)/2; 这样的意思是若出现一个偶数组一个奇数组，得到的中间位置一样。 因为保证两数组长度一样，会出现数组只有两个的情况，如果按上面的方法会出现 造成死循环。所以进行处理 12mid1=(la+ua)/2;mid2=(lb+ub)/2; 这样处理的都是0位置元素 递归终止条件 当两个数组都只有一个元素的时候，中位数肯定就是小的那一个。 经过上述两个元素数组的处理，会出现一种类型的情况，a数组有1个元素，b数组有2个元素，意味着a的元素大于b的第一个元素，按中位数的定义，比较b的第二个元素和a，小的那个就是中位数。同理a,b调换。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int a[100005];int b[100005];int binary(int la,int ua,int lb,int ub){ int mid1=(la+ua)/2,mid2=(lb+ub+1)/2; if(la==ua&amp;&amp;lb!=ub){ if(a[la]&gt;b[ub]){ return b[ub]; } return a[la]; } if(la!=ua&amp;&amp;lb==ub){ if(a[ua]&lt;b[ub]){ return a[ua]; } return b[ub]; } if(la==ua&amp;&amp;lb==ub){ if(a[la]&gt;b[lb]){ return b[lb]; } return a[la]; } else{ if(la+1==ua&amp;&amp;lb+1==ub){ mid1=(la+ua)/2; mid2=(lb+ub)/2; } if(a[mid1]==b[mid2]){ return a[mid1]; } if(a[mid1]&lt;b[mid2]){ return binary(mid1,ua,lb,mid2); } if(a[mid1]&gt;b[mid2]){ return binary(la,mid1,mid2,ub); } }}int main(){ int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } for(int i=0;i&lt;n;i++){ cin&gt;&gt;b[i]; } cout&lt;&lt;binary(0,n-1,0,n-1);}","link":"/2021/09/30/9-30%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E6%B2%BB%E4%B9%8B%E9%A2%98/"},{"title":"DS-ch6","text":"DS-ch6图论的算法包括 图的存储方式 邻接矩阵 邻接表 图的遍历 深度优先搜索（dfs） 广度优先搜索（bfs） 图的应用 最小生成树 普利姆算法（从一棵小树长大） 克鲁斯卡尔算法（选择最小边） 最短路径 迪杰斯特拉算法（单源最短路） 弗洛伊德算法（多源最短路） L3天梯赛——地铁一日游这道题看题解看了一上午才终于似懂非懂，由于魔都的地铁路线是以两点的最短路计费，所以当然要求最短路径，并且是多源有权图的最短路径，所以用弗洛伊德算法。这个森森，他要选择相同计费前提下距离最远的站点或者线路末端拍照，所以需要一个map，记录相同费用下的最大距离(map[‘一个费用’]=’最大距离’)，当出发点到这个结点(mp [i] [j])的距离是等于这个最大距离的时候，或者此结点本身是线路末端的时候，把它放进一个vector（res）保存，方便dfs的时候遍历标记，需要注意，当他出去站点的时候，他还可以再进来，再重新选择相同费用的最大距离的站点，所以用dfs。 思路如下： 对于每个结点创建一个结构体保存它在每个相同费用下能够达到的结点，ends表示它是否为末端，visit表示现在是由哪个结点出发 1234567struct station{ int visit,ends; station(){ visit=ends=0; } vector&lt;int&gt; res;*//所有可到达的站* }sta[MAX]; mp [i] [j]存放从i到j的最短路径，初始化时有边相连则赋值权重，无边的时候则赋最大值。之后用弗洛伊德算法的三重循环使mp[i] [j]存的是最短路 floyed(){//Floyed求最短路径1234567891011void floyed(){//Floyed求最短路径 for(int k=1;k&lt;=n;k++){ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ if(i!=j&amp;&amp;mp[i][j]&gt;mp[i][k]+mp[k][j]){ mp[i][j]=mp[i][k]+mp[k][j]; } } } }} 接着计算可能产生的费用，mp[i] [j]/k+2作为map m1的键，遍历结点，找出i相应费用的最大距离，当从i到j的距离是费用的最大距离或者j是末端点，则把j放入i的res数组中 i12345678910111213for(int i=1;i&lt;=n;i++){//对于每个站而言，寻找每个费用的最远距离,并将结果存入res中 map&lt;int,int&gt; m1; for(int j=1;j&lt;=n;j++){ if(mp[i][j]!=INF&amp;&amp;mp[i][j]&gt;m1[mp[i][j]/k+2]){ m1[mp[i][j]/k+2]=mp[i][j]; } } for(int j=1;j&lt;=n;j++){ if(mp[i][j]==m1[mp[i][j]/k+2]||(i!=j&amp;&amp;mp[i][j]!=INF&amp;&amp;sta[j].ends==1)) { sta[i].res.push_back(j); } } } 输入森森打算出发的结点i，并且dfs i的res数组，把它能够到的结点打上标记 dfs(int i,int vis){123456789void dfs(int i,int vis){for(int j=0;j&lt;sta[i].res.size();j++){ int t=sta[i].res[j]; if(sta[t].visit!=vis){ sta[t].visit=vis; dfs(t,vis); } }} 再次遍历结点，若标点为出发点，则将它输出即可 我太菜了 L3-014 周游世界 (30 分)dfs+回溯 用一个结构体数组存储一个结点的相邻节点和所属公司的信息。从一个结点出发，通过遍历这个结点编号的数组就可以得到它的下一个站点和公司信息，因为有的站点有可能是换乘站，所以它数组元素不止一个，注意双向存储，因为线路是双向的。dfs传递的参数站点数量，公司数量，以及它前一个公司的编号，因为要通过公司编号判断是否是换乘。如果不是换乘，则直接递归下一站，如果是换乘，则需要把换乘站（包括起点）压入一个数组中，当前公司编号也要压入数组中。本题是dfs递归+回溯，通过回溯不断更新最少站点和最少换乘站，可以找到最终结果。 最难的回溯部分 123456789101112131415161718192021222324252627void dfs(int a,int snum,int cnum,int com){ if(a==en){ if(stationnum&gt;snum||stationnum==snum&amp;&amp;cnum&lt;companynum){ stationnum=snum; companynum=cnum; path=t1; companypath=t2; } return ; } for(int i=0;i&lt;vec[a].size();i++){ if(vis[vec[a][i].next]){ continue; } vis[vec[a][i].next]=1; if(vec[a][i].company==com){ dfs(vec[a][i].next,snum+1,cnum,com); }else{ t1.push_back(a); t2.push_back(vec[a][i].company); dfs(vec[a][i].next,snum+1,cnum+1,vec[a][i].company); t1.pop_back(); t2.pop_back(); } vis[vec[a][i].next]=0; }} 这种算法应该写起来最简单了，咋一看像最短路问题，我太菜了","link":"/2021/05/23/DS-ch6/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/29/hello-world/"},{"title":"Hexo+icarus","text":"前言之前的matery主题因为上传图片失败拖了几个月没有管，这次写了篇分治想重新上传，按照教程下载hexo-asset-image，其实已经下载成功了，却因为事隔太久看到warn误以为失败，加上预览的时候加载不到图片（当时不知道是它自己的bug），就根据错误瞎折腾。也不知道修改了什么，居然连渲染页面都不能用，当时只觉得很奇怪，也没有debug。我怀疑码云上的网站和仓库断开了，确定代码推送到仓库但网页还是以前一样。matery的风格也和本校同学冲撞了，而且看起来花里胡哨，干脆再做一个。然而因为权限问题删除原文件夹删了半天，把权限从everyone到本地账户改来改去都不行，最后直接移到program file删了。本来使用next，以为很简单的事预览的时候网页只显示 {% extends ‘_layout.swig‘ %} {% import ‘_macro/post.swig‘ as post_template %} 原来是hexo在5.0之后把swig给删除了需要自己手动安装： npm install hexo-renderer-swig 之后分类页，标签页已经创建了然而网页还是404。干脆不搞了，对hexo产生了畏惧心理。之前没有总结建博客，现在认真记一些 Hexo预备环境 git github账号 node.js以及npm 安装hexonpm install -g hexo-cli cd到想要放置项目的目录，打开git hexo init blog cd 到blog npm install 接着就可以hexo s看看效果了，打开http://localhost:4000 hexo常用命令： 清理下：hexo clean 生成下：hexo g 启动下：hexo s 新建文章：hexo new &quot;文件名&quot; 部署：hexo d 部署到github上：npm install --save hexo-deployer-git 在blog目录下打开_config.yml，hexo全局配置文件，修改： 1234deploy: type: git repository: git@github.com:risotoonero/risotoonero.github.io branch: master 记得title和author写上自己的，然后hexo d就可以在github上看到效果。 icarus主题git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus 更改_config.yml中的theme，hexo升级后有点奇怪，它的配置文件在blog下的_config.icarus.yml。这样还不能马上看到效果，可能是icarus需要相关依赖： npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^0.4.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 安装成功的结果是这样的，别再搞乌龙了 结果安装版本不对 npm install --save hexo-component-inferno@^0.13.0 上传图片npm install hexo-asset-image --save 修改_config.yml的post_asset_folder改为true 在new了一篇文章后可以看到除了.md还有一个同名的文件夹，那是用来存图片的，文章中的图片路径名可以用文件名/图片名，就是在这里试来试去都不成功，心态都崩了，后面反应过来了是该死的文件路径出错了： io是什么呢，小编也很异或，上网一查 hexo-asset-image的bug 解决方案 link = link.substring(beginPos, endPos) + '/' + appendLink var endPos = link.length-1; 接下来就是主题配置的问题了，部分的配置信息如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181# Version of the Icarus theme that is currently usedversion: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicons.ico# Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/gen.svg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: '你的gityhub地址'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'http://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/honbao.PNG' - # 微信 type: wechat # 二维码图片 qrcode: '/images/yjtp.png' -# 分享插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: '/images/ava.png' # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/yourname' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/yourname' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com/yourname' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: 'https://google.com' Baidu: 'https://baidu.com' 注意图片一定要放在theme的img下才能找到 页面点击出现爱心在\\blog\\themes\\icarus\\source\\js下，新建clicklove.js，写入以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142!function(e,t,a){ function n(){ c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;), o(), r() } function r(){ for(var e=0;e&lt;d.length;e++) d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;); requestAnimationFrame(r) } function o(){ var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick; e.onclick=function(e){ t&amp;&amp;t(),i(e) } }function i(e){ var a=t.createElement(&quot;div&quot;); a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a) } function c(e){ var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;; try{ a.appendChild(t.createTextNode(e)) } catch(t){ a.styleSheet.cssText=e } t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) } function s(){ return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot; } var d=[]; e.requestAnimationFrame=function(){ return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){ setTimeout(e,1e3/60) } }(), n()}(window,document); 修改layout.ejs，找到\\blog\\themes\\icarus\\layout\\layout.ejs,添加： 文章目录在文章开头加上toc: true 板娘板娘很奇怪，我想要只猫，但换了两个模型都是那个女孩，匪夷所思。 npm install hexo-helper-live2d --save 在主题配置文件加上一段 12345678910111213141516live2d: enable: true #开启看板娘 scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-tororo #指定模型任务 display: position: right #显示位置 width: 200 #模型宽度 height: 400 #模型高度 mobile: show: true 评论插件123456type: valineapp_id: app_key: notify: true verify: true placeholder: 遇到这些报错就是主题文件配置错误，应该要自己找到 我遇到的问题 把widgets放在右边无效，只能全部在左边 article的thumbnail: true无效，文章thumbnail的路径设为/2021/09/30/9-30关于排序和分治之题/0.jpg才访问得到，只有缩略图，主页的文章封面没有，更不用说banner连图片都没有。想着每次写文章都要准备一张封面挺麻烦，而且博客简洁点就好，就算了。 public文件夹是网页呈现的东西","link":"/2021/10/02/Hexo-icarus/"},{"title":"不同的二叉搜索树 II","text":"不同的二叉搜索树 II无解的解法一：回溯之前的回溯有两个错误，一是只能产生单支树，根结点为1或3的时候没发现，为2的时候就发现了[[2,1,null,null,3],[2,null,3,1,null]]，因为我的递归有问题；二是不知为什么，比如[[1,null,2,null,3],[1,null,3,2]]之后，会出现[1,null,3]这样的诡异结果。 其实再早之前的回溯也有很大的问题，只能出现一种解的原因是第一种解出现，结点上就有值，就不能把第二解赋给结点，起初以为放入vector之后，把head-&gt;left，head-&gt;right置空就行，然而head是指针，置空的话就会把原来放入vector的值都置空了，无奈只能新建一棵树h，把head复制进h，再把head置空。然后出现上述的情形。 123456789101112131415161718192021222324252627282930313233343536373839404142434445void Copy(TreeNode* t,TreeNode* &amp;newt){ if(t==NULL){ newt = NULL; return; } else{ newt = new TreeNode; newt-&gt;val = t-&gt;val; Copy(t-&gt;left,newt-&gt;left); Copy(t-&gt;right,newt-&gt;right); } }void digui(TreeNode* &amp;head,TreeNode* &amp;tree,int i,int j,int n){ if(!tree){ TreeNode* tree1=new TreeNode; tree1-&gt;val=i; tree1-&gt;left=tree1-&gt;right=nullptr; tree=tree1; a[i]=1; ++j; if(j==n){ TreeNode* h=nullptr; Copy(head,h); v.push_back(h); for(int k=1;k&lt;=n;k++){ if(k==head-&gt;val){ continue; } a[k]=0; } head-&gt;left=nullptr; head-&gt;right=nullptr; return ; } for(int p=1;p&lt;=n;p++){ if(a[p]==0){ digui(head,tree,p,j,n); } } }else if(i&lt;tree-&gt;val){ digui(head,tree-&gt;left,i,j,n); }else if(i&gt;tree-&gt;val){ digui(head,tree-&gt;right,i,j,n); } } 现在改进了一下回溯，在赋值给根结点（j==1）之后进入递归，j&gt;=1时return，这样就避免了单支树情况。但是这样又有了新的问题，那就是，比如根结点为1时，只能解出1，2，3的顺序，而没有1，3，2的顺序，因为直接return的时候循环也遍历完了。所以再改进，回溯的最终代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution { vector&lt;TreeNode*&gt; v; int a[10]; void Copy(TreeNode* t,TreeNode* &amp;newt){ if(t==NULL){ newt = NULL; return; } else{ newt = new TreeNode; newt-&gt;val = t-&gt;val; Copy(t-&gt;left,newt-&gt;left); Copy(t-&gt;right,newt-&gt;right); } } void digui(TreeNode* &amp;head,TreeNode* &amp;tree,int i,int &amp;j,int n){ if(!tree){ TreeNode* tree1=new TreeNode; tree1-&gt;val=i; tree1-&gt;left=tree1-&gt;right=nullptr; tree=tree1; a[i]=1; ++j; if(j==n){ TreeNode* h=nullptr; Copy(head,h); v.push_back(h); for(int k=1;k&lt;=n;k++){ if(k==head-&gt;val){ continue; } a[k]=0; } head-&gt;left=nullptr; head-&gt;right=nullptr; j=1; return ; } if(j==1){ for(int u=1;u&lt;=n;u++){ if(a[u]==0){ digui(head,tree,u,j,n); for(int p=1;p&lt;=n;p++){ if(a[p]==0&amp;&amp;p!=u){ digui(head,tree,p,j,n); } } } } }else{ return ; } }else if(i&lt;tree-&gt;val){ digui(head,tree-&gt;left,i,j,n); }else if(i&gt;tree-&gt;val){ digui(head,tree-&gt;right,i,j,n); } }public: vector&lt;TreeNode*&gt; generateTrees(int n) { int i=1,j=0; while(i&lt;=n){ TreeNode* tree=nullptr; digui(tree,tree,i,j,n); i++; j=0; for(int k=1;k&lt;=n;k++){ a[k]=0; } } return v; }}; 最终的结果： 1[[1,null,2,null,3],[1,null,3,2],[2,1,3],[2,1,3],[3,1,null,null,2],[3,2,null,1]] 回溯的时候无可避免地出现了重复的结果，比如2，1，3和2，3，1的结果是一样的。所以我的回溯最终的结果只能到这里。虽然行不通，但做题的过程中学到了许多，而且花费的时间也很多。看题解采用的是二叉搜索树的特点和递归。 官方解法二：递归递归，leetcode官方解法说是回溯，我不知道哪里有回溯 12345678910111213141516171819202122232425262728293031class Solution { vector&lt;TreeNode*&gt; generate(int m,int n){ vector&lt;TreeNode*&gt; v1; vector&lt;TreeNode*&gt; v2; vector&lt;TreeNode*&gt; v3; if(m&gt;n){ return {nullptr}; } for(int i=m;i&lt;=n;i++){ v1=generate(m,i-1); v2=generate(i+1,n); for(auto tree:v1){ for(auto tree2:v2){ TreeNode* t=new TreeNode; t-&gt;val=i; t-&gt;left=tree; t-&gt;right=tree2; v3.push_back(t); } } } return v3; }public: vector&lt;TreeNode*&gt; generateTrees(int n) { if(n==0){ return {nullptr}; } return generate(1,n); }}; 二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为 n，如果我们枚举根节点的值为 i，那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1…i−1]，右子树的节点值的集合为 [i+1…n]。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题。 我们定义 generate(start, end) 函数表示当前值的集合为 [start,end]，返回序列[start,end] 生成的所有可行的二叉搜索树。按照上文的思路，我们考虑枚举 [start,end] 中的值 ii 为当前二叉搜索树的根，那么序列划分为了[start,i−1] 和 [i+1,end] 两部分。我们递归调用这两部分，即 generateTrees(start, i - 1) 和 generateTrees(i + 1, end)，获得所有可行的左子树和可行的右子树，那么最后一步我们只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。 递归的入口即为 generateTrees(1, n)，出口为当 start&gt;end 的时候，当前二叉搜索树为空，返回空节点即可。 解法三：动态规划12345678910111213141516171819202122232425262728293031323334class Solution { TreeNode* clone(TreeNode* tree2,int offset){ if(!tree2){ return nullptr; } TreeNode* tree3=new TreeNode(tree2-&gt;val+offset); tree3-&gt;left=clone(tree2-&gt;left,offset); tree3-&gt;right=clone(tree2-&gt;right,offset); return tree3; }public: vector&lt;TreeNode*&gt; generateTrees(int n) { if(n==0){ return {nullptr}; } vector&lt;vector&lt;TreeNode*&gt;&gt; dp(n+1); dp[0].push_back({nullptr}); for(int len=1;len&lt;=n;len++){ for(int root=1;root&lt;=len;root++){ int left=root-1; int right=len-root; for(auto&amp; tree1:dp[left]){ for(auto&amp; tree2:dp[right]){ TreeNode* tree=new TreeNode(root); tree-&gt;left=tree1; tree-&gt;right=clone(tree2,root); dp[len].push_back(tree); } } } } return dp[n]; }}; 第一次报错数组为空是因为vector二维数组初始化问题，需要写上v(n+1)才可。 动态规划的思想是从元素个数入手，先算出个数为1的所有树，个数为2的所有树….直到n。对于每一个长度的树，遍历根结点，根结点为3的树，它的左子树的元素都比它小（1、2），所以加上个数为2的所有可能性；根结点为2的树，左子树元素为1，因此加上个数为1的所有子树，同理右子树。采用自底向上的方法。可以观察到所有长度为2的树（1、2；2、1）和（2，3；3，2）只是元素数值不相同，结构是一样的。所以没必要再求一次，只需要把长度为2的树克隆一份，加上根结点的值即可，同理长度为n的也一样。可以参考题解： 解法三 解法四：动态规划123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public List&lt;TreeNode&gt; generateTrees(int n) { List&lt;TreeNode&gt; pre = new ArrayList&lt;TreeNode&gt;(); if (n == 0) { return pre; } pre.add(null); //每次增加一个数字 for (int i = 1; i &lt;= n; i++) { List&lt;TreeNode&gt; cur = new ArrayList&lt;TreeNode&gt;(); //遍历之前的所有解 for (TreeNode root : pre) { //插入到根节点 TreeNode insert = new TreeNode(i); insert.left = root; cur.add(insert); //插入到右孩子，右孩子的右孩子...最多找 n 次孩子 for (int j = 0; j &lt;= n; j++) { TreeNode root_copy = treeCopy(root); //复制当前的树 TreeNode right = root_copy; //找到要插入右孩子的位置 int k = 0; //遍历 j 次找右孩子 for (; k &lt; j; k++) { if (right == null) break; right = right.right; } //到达 null 提前结束 if (right == null) break; //保存当前右孩子的位置的子树作为插入节点的左孩子 TreeNode rightTree = right.right; insert = new TreeNode(i); right.right = insert; //右孩子是插入的节点 insert.left = rightTree; //插入节点的左孩子更新为插入位置之前的子树 //加入结果中 cur.add(root_copy); } } pre = cur; } return pre;}private TreeNode treeCopy(TreeNode root) { if (root == null) { return root; } TreeNode newRoot = new TreeNode(root.val); newRoot.left = treeCopy(root.left); newRoot.right = treeCopy(root.right); return newRoot;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { TreeNode* copy(TreeNode* head){ if(!head){ return nullptr; } TreeNode* newtree=new TreeNode(head-&gt;val); newtree-&gt;left=copy(head-&gt;left) ; newtree-&gt;right=copy(head-&gt;right); return newtree; }public: vector&lt;TreeNode*&gt; generateTrees(int n) { if(n==0){ return {nullptr}; } vector&lt;TreeNode*&gt; pre; pre.push_back({nullptr}); for(int i=1;i&lt;=n;i++){ vector&lt;TreeNode*&gt; now; for(auto&amp; t:pre){ TreeNode* tree=new TreeNode(i); tree-&gt;left=t; now.push_back(tree); for(int j=0;j&lt;=n;j++){//从0开始，因为根结点右边也可以加 TreeNode* t4=copy(t);//在j这个循环中如果不复制t就会被改变 TreeNode* t1=t4; for(int k=0;k&lt;j;k++){//(注意这里不能写成k&lt;=j,因为循环了j次之后t1会到达nullptr，直接break，无法在右子树插入新结点，结果只有根结点) if(t1==NULL){//Line 40: Char 32: runtime error: member access within null pointer of type 'TreeNode' (solution.cpp)(t1-&gt;right==NULL报错)SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:49:32 break; } t1=t1-&gt;right; } if(!t1){ break; } TreeNode* t3=new TreeNode(i); TreeNode* tmp=t1-&gt;right; t1-&gt;right=t3; t3-&gt;left=tmp; now.push_back(t4); } } pre=now; } return pre; }};","link":"/2021/10/16/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II/"},{"title":"数学之美第5章","text":"隐含马尔可夫模型通信模型语音识别，机器翻译，文本纠错，都是根据发送者传送的一串信息s1,s2,…st经过一定的编码方式o1,o2,..,ot传送到接收者，接收者解码还原为s1,s2,..st。要从接收到的信息还原，只需要在原数据中找出最可能产生o1,o2,..ot的那串信息即可。用概率论表述，在已知o1,o2,..ot的情况下，求使P(s1,s2,…st|o1,o2,..,ot)最大的信息串s1,s2,…st：$$s1,s2,..st=ArgMax P(s1,s2,…st|o1,o2,..,ot)$$ArgMax表示能获得最大值的那个参数argument。 P(s1,s2,…st|o1,o2,..,ot)使用贝叶斯变换得到：$$P(s1,s2,…st|o1,o2,..,ot)=\\frac{P(o1,o2,..,ot|s1,s2,…st)*P(s1,s2,…st)}{P(o1,o2,..,ot)}(5.5)$$由于P(o1,o2,..,ot)已经确定，所以它可以作为一个常数，只需要计算上面的部分。 隐含马尔可夫模型每一个状态St出现的概率，都与上一次的状态St-1有关。根据转移概率，可以由当前的状态计算出下一个状态的概率。即P(St|St-1,St-2,…,S1)=P(St|St-1)。隐含马尔可夫模型是马尔可夫链的一个扩展，每一个状态St是不可见的，所以没法计算出转移概率，但是看得见一个独立输出假设Ot，仅仅与St有关。St即发送者原信号，Ot即接收端接收到的信号。我们可以计算出出现每个输出假设的概率：$$P(s1,s2,…,o1,o2,..,ot)=\\prod_{t}P(St|St-1)*P(Ot|St)(5.6)$$P(St|St-1)表示状态St出现的概率，P(Ot|St)表示根据St能产生Ot的概率。 其中$$P(o1,o2,..,ot|s1,s2,…st)=\\prod_{t}P(Ot|St)$$ $$P(s1,s2…st)=\\prod_{t}P(St|St-1)$$ 把这两条公式代入（5.5），就可以得到（5.6）。至于找出上述式子的最大值，可以用维特比算法。 模型的训练如何根据观测数据，得到隐含马尔可夫模型的参数?根据条件概率的定义$$P(Ot|St)=\\frac{P(Ot,St)}{P(St)}$$ $$P(St|St-1)=\\frac{P(St,St-1)}{P(St-1)}$$ 利用人工标注的数据，可以直接得到状态St出现的次数等等，这种方法叫做有监督的训练方法。人工基本做不到。 直接通过大量观测到的信号就能推算出参数的方法，称为无监督的训练方法。其中主要使用鲍姆韦尔奇算法。首先找到一组能够产生输出序列的模型参数，得到一个初始模型$$M_{\\theta0}$$，可以算出这个模型产生O的概率P(O|$$M_{\\theta0}$$)，以及产生O的所有可能的路径和这些路径的概率。然后计算另一个模型的参数$$P(O|M_{\\theta1})&gt;P(O|M_{\\theta0})$$不断迭代就能找出最好的模型。","link":"/2021/10/13/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E7%AC%AC5%E7%AB%A0/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"算法心得","slug":"算法心得","link":"/tags/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"回溯","slug":"回溯","link":"/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"数学之美","slug":"数学之美","link":"/tags/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"阅读","slug":"阅读","link":"/categories/%E9%98%85%E8%AF%BB/"}]}