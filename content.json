{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"9.30关于排序和分治之题","text":"leetcode算法面试题排序与索引最大数把数字转化为字符串，把两个字符串拼接起来，用字符串来进行比较和排序 摆动排序用快排排好后，逆序穿插，把第一大，第二大插到数组第1位，第3位，插到末尾就把剩下逆序插到第0位，第2位，保证摆动。至于为什么这样可以保证搞不懂。 寻找重复数忽略了题目的一个条件，所有数都在1到n之间。所以二分法查询的不是位置，而是1-n的数。比这个数小的，不能大于这个数，因为要没有重复。如果大过了，就证明在0-这个数之间有数重复，所以在这个区间上找。如果没有重复的话，就在n-len这个区间上找。 如果寻找的是不重复数，可以直接用位运算，一个数与0异或等于它本身，两个相同数异或等于0。 寻找峰值看不透问题的本质，直接用这个数是否大于左边，是否大于右边来算，用二分法不能判断最大数在哪个区间，只能左边区间和右边区间同样递归，时间复杂度反而是指数了，而且边界条件根本判断不了。其实普通的二分法，要求最大数，只要右边这个数不能大于它就行了。大于它的话说明还有数比它大，所以右边区间一定有最大数，不用管左边区间有没有最大数。否则这个数也许是最大数，就在左边找。真的为自己的智商堪忧。 算法实验课两个有序序列的中位数(分治)时间复杂度为log(n)，首先基本思想因为两个数组已经排好，而且求中位数，所以比较两个数组的中间元素，要是相等，则因为都是中位数，这两个数一定挨在一起，则整体的中位数必定是这个数，所以直接返回这个数。具体看下图 所以基本思路就是这样。为了保证递归的时候两个子数组长度相等，对mid可以这样处理 12mid1=(la+ua)/2;mid2=(lb+ub+1)/2; 这样的意思是若出现一个偶数组一个奇数组，得到的中间位置一样。 因为保证两数组长度一样，会出现数组只有两个的情况，如果按上面的方法会出现 造成死循环。所以进行处理 12mid1=(la+ua)/2;mid2=(lb+ub)/2; 这样处理的都是0位置元素 递归终止条件 当两个数组都只有一个元素的时候，中位数肯定就是小的那一个。 经过上述两个元素数组的处理，会出现一种类型的情况，a数组有1个元素，b数组有2个元素，意味着a的元素大于b的第一个元素，按中位数的定义，比较b的第二个元素和a，小的那个就是中位数。同理a,b调换。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int a[100005];int b[100005];int binary(int la,int ua,int lb,int ub){ int mid1=(la+ua)/2,mid2=(lb+ub+1)/2; if(la==ua&amp;&amp;lb!=ub){ if(a[la]&gt;b[ub]){ return b[ub]; } return a[la]; } if(la!=ua&amp;&amp;lb==ub){ if(a[ua]&lt;b[ub]){ return a[ua]; } return b[ub]; } if(la==ua&amp;&amp;lb==ub){ if(a[la]&gt;b[lb]){ return b[lb]; } return a[la]; } else{ if(la+1==ua&amp;&amp;lb+1==ub){ mid1=(la+ua)/2; mid2=(lb+ub)/2; } if(a[mid1]==b[mid2]){ return a[mid1]; } if(a[mid1]&lt;b[mid2]){ return binary(mid1,ua,lb,mid2); } if(a[mid1]&gt;b[mid2]){ return binary(la,mid1,mid2,ub); } }}int main(){ int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } for(int i=0;i&lt;n;i++){ cin&gt;&gt;b[i]; } cout&lt;&lt;binary(0,n-1,0,n-1);}","link":"/2021/09/30/9-30%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E6%B2%BB%E4%B9%8B%E9%A2%98/"},{"title":"DS-ch6","text":"DS-ch6图论的算法包括 图的存储方式 邻接矩阵 邻接表 图的遍历 深度优先搜索（dfs） 广度优先搜索（bfs） 图的应用 最小生成树 普利姆算法（从一棵小树长大） 克鲁斯卡尔算法（选择最小边） 最短路径 迪杰斯特拉算法（单源最短路） 弗洛伊德算法（多源最短路） L3天梯赛——地铁一日游这道题看题解看了一上午才终于似懂非懂，由于魔都的地铁路线是以两点的最短路计费，所以当然要求最短路径，并且是多源有权图的最短路径，所以用弗洛伊德算法。这个森森，他要选择相同计费前提下距离最远的站点或者线路末端拍照，所以需要一个map，记录相同费用下的最大距离(map[‘一个费用’]=’最大距离’)，当出发点到这个结点(mp [i] [j])的距离是等于这个最大距离的时候，或者此结点本身是线路末端的时候，把它放进一个vector（res）保存，方便dfs的时候遍历标记，需要注意，当他出去站点的时候，他还可以再进来，再重新选择相同费用的最大距离的站点，所以用dfs。 思路如下： 对于每个结点创建一个结构体保存它在每个相同费用下能够达到的结点，ends表示它是否为末端，visit表示现在是由哪个结点出发 1234567struct station{ int visit,ends; station(){ visit=ends=0; } vector&lt;int&gt; res;*//所有可到达的站* }sta[MAX]; mp [i] [j]存放从i到j的最短路径，初始化时有边相连则赋值权重，无边的时候则赋最大值。之后用弗洛伊德算法的三重循环使mp[i] [j]存的是最短路 floyed(){//Floyed求最短路径1234567891011void floyed(){//Floyed求最短路径 for(int k=1;k&lt;=n;k++){ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ if(i!=j&amp;&amp;mp[i][j]&gt;mp[i][k]+mp[k][j]){ mp[i][j]=mp[i][k]+mp[k][j]; } } } }} 接着计算可能产生的费用，mp[i] [j]/k+2作为map m1的键，遍历结点，找出i相应费用的最大距离，当从i到j的距离是费用的最大距离或者j是末端点，则把j放入i的res数组中 i12345678910111213for(int i=1;i&lt;=n;i++){//对于每个站而言，寻找每个费用的最远距离,并将结果存入res中 map&lt;int,int&gt; m1; for(int j=1;j&lt;=n;j++){ if(mp[i][j]!=INF&amp;&amp;mp[i][j]&gt;m1[mp[i][j]/k+2]){ m1[mp[i][j]/k+2]=mp[i][j]; } } for(int j=1;j&lt;=n;j++){ if(mp[i][j]==m1[mp[i][j]/k+2]||(i!=j&amp;&amp;mp[i][j]!=INF&amp;&amp;sta[j].ends==1)) { sta[i].res.push_back(j); } } } 输入森森打算出发的结点i，并且dfs i的res数组，把它能够到的结点打上标记 dfs(int i,int vis){123456789void dfs(int i,int vis){for(int j=0;j&lt;sta[i].res.size();j++){ int t=sta[i].res[j]; if(sta[t].visit!=vis){ sta[t].visit=vis; dfs(t,vis); } }} 再次遍历结点，若标点为出发点，则将它输出即可 我太菜了 L3-014 周游世界 (30 分)dfs+回溯 用一个结构体数组存储一个结点的相邻节点和所属公司的信息。从一个结点出发，通过遍历这个结点编号的数组就可以得到它的下一个站点和公司信息，因为有的站点有可能是换乘站，所以它数组元素不止一个，注意双向存储，因为线路是双向的。dfs传递的参数站点数量，公司数量，以及它前一个公司的编号，因为要通过公司编号判断是否是换乘。如果不是换乘，则直接递归下一站，如果是换乘，则需要把换乘站（包括起点）压入一个数组中，当前公司编号也要压入数组中。本题是dfs递归+回溯，通过回溯不断更新最少站点和最少换乘站，可以找到最终结果。 最难的回溯部分 123456789101112131415161718192021222324252627void dfs(int a,int snum,int cnum,int com){ if(a==en){ if(stationnum&gt;snum||stationnum==snum&amp;&amp;cnum&lt;companynum){ stationnum=snum; companynum=cnum; path=t1; companypath=t2; } return ; } for(int i=0;i&lt;vec[a].size();i++){ if(vis[vec[a][i].next]){ continue; } vis[vec[a][i].next]=1; if(vec[a][i].company==com){ dfs(vec[a][i].next,snum+1,cnum,com); }else{ t1.push_back(a); t2.push_back(vec[a][i].company); dfs(vec[a][i].next,snum+1,cnum+1,vec[a][i].company); t1.pop_back(); t2.pop_back(); } vis[vec[a][i].next]=0; }} 这种算法应该写起来最简单了，咋一看像最短路问题，我太菜了","link":"/2021/05/23/DS-ch6/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/09/29/hello-world/"},{"title":"Hexo+icarus","text":"前言之前的matery主题因为上传图片失败拖了几个月没有管，这次写了篇分治想重新上传，按照教程下载hexo-asset-image，其实已经下载成功了，却因为事隔太久看到warn误以为失败，加上预览的时候加载不到图片（当时不知道是它自己的bug），就根据错误瞎折腾。也不知道修改了什么，居然连渲染页面都不能用，当时只觉得很奇怪，也没有debug。我怀疑码云上的网站和仓库断开了，确定代码推送到仓库但网页还是以前一样。matery的风格也和本校同学冲撞了，而且看起来花里胡哨，干脆再做一个。然而因为权限问题删除原文件夹删了半天，把权限从everyone到本地账户改来改去都不行，最后直接移到program file删了。本来使用next，以为很简单的事预览的时候网页只显示 {% extends ‘_layout.swig‘ %} {% import ‘_macro/post.swig‘ as post_template %} 原来是hexo在5.0之后把swig给删除了需要自己手动安装： npm install hexo-renderer-swig 之后分类页，标签页已经创建了然而网页还是404。干脆不搞了，对hexo产生了畏惧心理。之前没有总结建博客，现在认真记一些 Hexo预备环境 git github账号 node.js以及npm 安装hexonpm install -g hexo-cli cd到想要放置项目的目录，打开git hexo init blog cd 到blog npm install 接着就可以hexo s看看效果了，打开http://localhost:4000 hexo常用命令： 清理下：hexo clean 生成下：hexo g 启动下：hexo s 新建文章：hexo new &quot;文件名&quot; 部署：hexo d 部署到github上：npm install --save hexo-deployer-git 在blog目录下打开_config.yml，hexo全局配置文件，修改： 1234deploy: type: git repository: git@github.com:risotoonero/risotoonero.github.io branch: master 记得title和author写上自己的，然后hexo d就可以在github上看到效果。 icarus主题git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus 更改_config.yml中的theme，hexo升级后有点奇怪，它的配置文件在blog下的_config.icarus.yml。这样还不能马上看到效果，可能是icarus需要相关依赖： npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^0.4.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 安装成功的结果是这样的，别再搞乌龙了 结果安装版本不对 npm install --save hexo-component-inferno@^0.13.0 上传图片npm install hexo-asset-image --save 修改_config.yml的post_asset_folder改为true 在new了一篇文章后可以看到除了.md还有一个同名的文件夹，那是用来存图片的，文章中的图片路径名可以用文件名/图片名，就是在这里试来试去都不成功，心态都崩了，后面反应过来了是该死的文件路径出错了： io是什么呢，小编也很异或，上网一查 hexo-asset-image的bug 解决方案 link = link.substring(beginPos, endPos) + '/' + appendLink var endPos = link.length-1; 接下来就是主题配置的问题了，部分的配置信息如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181# Version of the Icarus theme that is currently usedversion: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicons.ico# Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/gen.svg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: '你的gityhub地址'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'http://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/honbao.PNG' - # 微信 type: wechat # 二维码图片 qrcode: '/images/yjtp.png' -# 分享插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: '/images/ava.png' # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/yourname' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/yourname' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com/yourname' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: 'https://google.com' Baidu: 'https://baidu.com' 注意图片一定要放在theme的img下才能找到 页面点击出现爱心在\\blog\\themes\\icarus\\source\\js下，新建clicklove.js，写入以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142!function(e,t,a){ function n(){ c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;), o(), r() } function r(){ for(var e=0;e&lt;d.length;e++) d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;); requestAnimationFrame(r) } function o(){ var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick; e.onclick=function(e){ t&amp;&amp;t(),i(e) } }function i(e){ var a=t.createElement(&quot;div&quot;); a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a) } function c(e){ var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;; try{ a.appendChild(t.createTextNode(e)) } catch(t){ a.styleSheet.cssText=e } t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) } function s(){ return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot; } var d=[]; e.requestAnimationFrame=function(){ return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){ setTimeout(e,1e3/60) } }(), n()}(window,document); 修改layout.ejs，找到\\blog\\themes\\icarus\\layout\\layout.ejs,添加： 文章目录在文章开头加上toc: true 板娘板娘很奇怪，我想要只猫，但换了两个模型都是那个女孩，匪夷所思。 npm install hexo-helper-live2d --save 在主题配置文件加上一段 12345678910111213141516live2d: enable: true #开启看板娘 scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-tororo #指定模型任务 display: position: right #显示位置 width: 200 #模型宽度 height: 400 #模型高度 mobile: show: true 评论插件123456type: valineapp_id: app_key: notify: true verify: true placeholder: 遇到这些报错就是主题文件配置错误，应该要自己找到 我遇到的问题 把widgets放在右边无效，只能全部在左边 article的thumbnail: true无效，文章thumbnail的路径设为/2021/09/30/9-30关于排序和分治之题/0.jpg才访问得到，只有缩略图，主页的文章封面没有，更不用说banner连图片都没有。想着每次写文章都要准备一张封面挺麻烦，而且博客简洁点就好，就算了。 public文件夹是网页呈现的东西","link":"/2021/10/02/Hexo-icarus/"},{"title":"10-5动规","text":"Leetcode传递信息这题乍看之下和pta出租游艇很像，其实不然。主要是多了个k轮传递的限制 代码如下，时间复杂度100左右 123456789101112131415161718192021222324252627282930313233343536class Solution { int m[100][100]; int a[100][100];public: int numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) { for(int i=0;i&lt;relation.size();i++){ a[relation[i][0]][relation[i][1]]=1; } for(int j=1;j&lt;=k;j++){ if(j==1){ for(int r=0;r&lt;n;r++){ if(a[0][r]&gt;0){ m[r][j]=1; } } }else{ for(int p=0;p&lt;n;p++){ if(m[p][j-1]&gt;0){ for(int r=0;r&lt;n;r++){ if(a[p][r]&gt;0){ if(m[r][j]==0){ m[r][j]=m[p][j-1]; }else{ m[r][j]+=m[p][j-1]; } } } } } } } return m[n-1][k]; }}; pta出租游艇长江游艇俱乐部在长江上设置了n个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为r(i,j),1&lt;=i&lt;j&lt;=n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n所需的最少租金。 第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的第1到第n-1 行，第i行表示第i站到第i+1站,第i+2站, … , 第n站的租金。 12335 157 相较于上题，这题用一维数组存储值就好了，m[3]就遍历1、2，用m[1]+1到3的钱，m[2]+2到3的钱，选小的那个。自底向上算 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int a[2000][2000];int m[2000];int main(){ int n; cin&gt;&gt;n; for(int i=1;i&lt;=n-1;i++){ for(int j=i+1;j&lt;=n;j++){ cin&gt;&gt;a[i][j]; } } for(int i=2;i&lt;=n;i++){ m[i]=INT_MAX; int u=0; for(int k=1;k&lt;i;k++){ if((a[k][i]&gt;0&amp;&amp;m[k]&gt;0&amp;&amp;k&gt;1)||(k==1&amp;&amp;a[k][i]&gt;0)){ u=m[k]+a[k][i]; if(u&lt;m[i]){ m[i]=u; } } } if(u==0){ m[i]=0; } } cout&lt;&lt;m[n]; } pta矩阵链动态规划有两个特点：最优子结构和重叠子问题。这道题的最优子结构是，要寻找矩阵i到j的最小乘法次数，可以在i~j中找到一个k，左边矩阵i到k的已经是一个最优序列，右边k+1到j也是一个最优序列，两边的乘法次数之和加上两个子问题的乘法次数(pi * pk * pj)就是i到j的最优解。而i到k，k+1到j也可以用递归算法求得。$$m[i][j]= \\begin{cases} 0, &amp; \\text{if $i$ =$j$}\\ \\min \\limits_{i&lt;=k&lt;j}{m[i][k]+m[k+1][j]+pipkpj} &amp; \\text{if $i$ &lt; $j$} \\end{cases}$$ 遍历k便得 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[1000];int m[1000][1000];int main(){ cin&gt;&gt;n; for(int i=0;i&lt;=n;i++){ cin&gt;&gt;a[i]; } for(int i=0;i&lt;=n;i++){ m[i][i]=0; } for(int i=n;i&gt;=1;i--){ for(int j=i+1;j&lt;=n;j++){ if(i&lt;j){ m[i][j]=m[i][i]+m[i+1][j]+a[i-1]*a[i]*a[j]; for(int k=i;k&lt;j;k++){ m[i][j]=min(m[i][j],m[i][k]+m[k+1][j]+a[i-1]*a[j]*a[k]); } } } } cout&lt;&lt;m[1][n];} leetcode连续子数组的最大和123输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 这道题碰到很多次了，开局把max设为无穷小，u=0，遍历数组，u+=nums[i],如果u比max大，赋值。如果u&lt;0,u=0","link":"/2021/10/05/10-5%E5%8A%A8%E8%A7%84/"}],"tags":[{"name":"算法心得","slug":"算法心得","link":"/tags/%E7%AE%97%E6%B3%95%E5%BF%83%E5%BE%97/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"categories":[{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}