<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10-13leetcode</title>
    <url>/2021/10/13/10-13leetcode/</url>
    <content><![CDATA[<h2 id="公平的糖果棒交换"><a href="#公平的糖果棒交换" class="headerlink" title="公平的糖果棒交换"></a><a href="https://leetcode-cn.com/problems/fair-candy-swap/">公平的糖果棒交换</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">fairCandySwap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; aliceSizes, vector&lt;<span class="keyword">int</span>&gt;&amp; bobSizes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1=aliceSizes.<span class="built_in">size</span>(),n2=bobSizes.<span class="built_in">size</span>(),sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n1;i++)&#123;</span><br><span class="line">            sum1+=aliceSizes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n2;i++)&#123;</span><br><span class="line">            sum2+=bobSizes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(aliceSizes.<span class="built_in">begin</span>(),aliceSizes.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(bobSizes.<span class="built_in">begin</span>(),bobSizes.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> temp=sum1-(sum1+sum2)/<span class="number">2</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n1&amp;&amp;j&lt;n2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(aliceSizes[i]-bobSizes[j]==temp)&#123;</span><br><span class="line">                c.<span class="built_in">push_back</span>(aliceSizes[i]);</span><br><span class="line">                c.<span class="built_in">push_back</span>(bobSizes[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aliceSizes[i]-bobSizes[j]&lt;temp)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="矩阵中战斗力最弱的-K-行"><a href="#矩阵中战斗力最弱的-K-行" class="headerlink" title="矩阵中战斗力最弱的 K 行"></a><a href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/">矩阵中战斗力最弱的 K 行</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.second!=p2.second)&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.second&lt;p2.second;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p1.first&lt;p2.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">kWeakestRows</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=mat.<span class="built_in">size</span>(),n=mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,sum));</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),compare);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            v2.<span class="built_in">push_back</span>(v[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>10-5动规</title>
    <url>/2021/10/05/10-5%E5%8A%A8%E8%A7%84/</url>
    <content><![CDATA[<h2 id="Leetcode传递信息"><a href="#Leetcode传递信息" class="headerlink" title="Leetcode传递信息"></a>Leetcode传递信息</h2><p>这题乍看之下和pta出租游艇很像，其实不然。主要是多了个k轮传递的限制</p>
<p><img src="/2021/10/05/10-5%E5%8A%A8%E8%A7%84/1.png"></p>
<span id="more"></span>

<p>代码如下，时间复杂度100左右</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;relation.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            a[relation[i][<span class="number">0</span>]][relation[i][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;          </span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;n;r++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(a[<span class="number">0</span>][r]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            m[r][j]=<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;n;p++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(m[p][j<span class="number">-1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;n;r++)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(a[p][r]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(m[r][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                                        m[r][j]=m[p][j<span class="number">-1</span>];</span><br><span class="line">                                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                        m[r][j]+=m[p][j<span class="number">-1</span>];</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    </span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[n<span class="number">-1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="pta出租游艇"><a href="#pta出租游艇" class="headerlink" title="pta出租游艇"></a>pta出租游艇</h2><p>长江游艇俱乐部在长江上设置了n个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为r(i,j),1&lt;=i&lt;j&lt;=n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n所需的最少租金。</p>
<p>第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的第1到第n-1 行，第i行表示第i站到第i+1站,第i+2站, … , 第n站的租金。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5 15</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>相较于上题，这题用一维数组存储值就好了，m[3]就遍历1、2，用m[1]+1到3的钱，m[2]+2到3的钱，选小的那个。自底向上算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		m[i]=INT_MAX;</span><br><span class="line">		<span class="keyword">int</span> u=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;i;k++)&#123;			</span><br><span class="line">			<span class="keyword">if</span>((a[k][i]&gt;<span class="number">0</span>&amp;&amp;m[k]&gt;<span class="number">0</span>&amp;&amp;k&gt;<span class="number">1</span>)||(k==<span class="number">1</span>&amp;&amp;a[k][i]&gt;<span class="number">0</span>))&#123;</span><br><span class="line">				u=m[k]+a[k][i];</span><br><span class="line">				<span class="keyword">if</span>(u&lt;m[i])&#123;</span><br><span class="line">					m[i]=u;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(u==<span class="number">0</span>)&#123;</span><br><span class="line">				m[i]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;m[n];	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pta矩阵链"><a href="#pta矩阵链" class="headerlink" title="pta矩阵链"></a>pta矩阵链</h2><p>动态规划有两个特点：最优子结构和重叠子问题。这道题的最优子结构是，要寻找矩阵i到j的最小乘法次数，可以在i~j中找到一个k，左边矩阵i到k的已经是一个最优序列，右边k+1到j也是一个最优序列，两边的乘法次数之和加上两个子问题的乘法次数(pi  *  pk * pj)就是i到j的最优解。而i到k，k+1到j也可以用递归算法求得。<br>$$<br>m[i][j]=<br>    \begin{cases}<br>        0, &amp; \text{if $i$ =$j$}\<br>        \min \limits_ {i&lt;=k&lt;j}{m[i][k]+m[k+1][j]+pi<em>pk</em>pj} &amp; \text{if $i$ &lt; $j$}<br>    \end{cases}<br>$$</p>
<p>遍历k便得</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		m[i][i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">				m[i][j]=m[i][i]+m[i+<span class="number">1</span>][j]+a[i<span class="number">-1</span>]*a[i]*a[j];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">					m[i][j]=<span class="built_in">min</span>(m[i][j],m[i][k]+m[k+<span class="number">1</span>][j]+a[i<span class="number">-1</span>]*a[j]*a[k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;m[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="leetcode连续子数组的最大和"><a href="#leetcode连续子数组的最大和" class="headerlink" title="leetcode连续子数组的最大和"></a>leetcode连续子数组的最大和</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p>这道题碰到很多次了，开局把max设为无穷小，<code>u=0</code>，遍历数组，<code>u+=nums[i]</code>,如果u比max大，赋值。如果<code>u&lt;0</code>,<code>u=0</code></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>9.30关于排序和分治之题</title>
    <url>/2021/09/30/9-30%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E6%B2%BB%E4%B9%8B%E9%A2%98/</url>
    <content><![CDATA[<h1 id="leetcode算法面试题排序与索引"><a href="#leetcode算法面试题排序与索引" class="headerlink" title="leetcode算法面试题排序与索引"></a>leetcode算法面试题排序与索引</h1><h2 id="最大数"><a href="#最大数" class="headerlink" title="最大数"></a>最大数</h2><p>把数字转化为字符串，把两个字符串拼接起来，用字符串来进行比较和排序</p>
<span id="more"></span>

<h2 id="摆动排序"><a href="#摆动排序" class="headerlink" title="摆动排序"></a>摆动排序</h2><p>用快排排好后，逆序穿插，把第一大，第二大插到数组第1位，第3位，插到末尾就把剩下逆序插到第0位，第2位，保证摆动。至于为什么这样可以保证搞不懂。</p>
<h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</span><br><span class="line"></span><br><span class="line">假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</span><br><span class="line"></span><br><span class="line">你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。</span><br></pre></td></tr></table></figure>

<p>忽略了题目的一个条件，所有数都在1到n之间。所以二分法查询的不是位置，而是1-n的数。比这个数小的，不能大于这个数，因为要没有重复。如果大过了，就证明在0-这个数之间有数重复，所以在这个区间上找。如果没有重复的话，就在n-len这个区间上找。</p>
<p>如果寻找的是不重复数，可以直接用位运算，一个数与0异或等于它本身，两个相同数异或等于0。</p>
<p>进阶：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。</span><br><span class="line"></span><br><span class="line">找到所有出现两次的元素。</span><br><span class="line"></span><br><span class="line">你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？</span><br></pre></td></tr></table></figure>

<p>重复元素不止一个，而且在O(n)复杂度。</p>
<p>技巧：遍历数组，元素值对应位置乘-1，如果一个元素出现了两次，它对应的位置已经乘了一次-1，如果&lt;0，则放入结果。</p>
<h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h2><p>看不透问题的本质，直接用这个数是否大于左边，是否大于右边来算，用二分法不能判断最大数在哪个区间，只能左边区间和右边区间同样递归，时间复杂度反而是指数了，而且边界条件根本判断不了。其实普通的二分法，要求最大数，只要右边这个数不能大于它就行了。大于它的话说明还有数比它大，所以右边区间一定有最大数，不用管左边区间有没有最大数。否则这个数也许是最大数，就在左边找。真的为自己的智商堪忧。</p>
<h1 id="算法实验课"><a href="#算法实验课" class="headerlink" title="算法实验课"></a>算法实验课</h1><h2 id="两个有序序列的中位数-分治"><a href="#两个有序序列的中位数-分治" class="headerlink" title="两个有序序列的中位数(分治)"></a>两个有序序列的中位数(分治)</h2><p>时间复杂度为log(n)，首先基本思想因为两个数组已经排好，而且求中位数，所以比较两个数组的中间元素，要是相等，则因为都是中位数，这两个数一定挨在一起，则整体的中位数必定是这个数，所以直接返回这个数。具体看下图</p>
<p><img src="/2021/09/30/9-30%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E6%B2%BB%E4%B9%8B%E9%A2%98/te.jpg"></p>
<p>所以基本思路就是这样。为了保证递归的时候两个子数组长度相等，对mid可以这样处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mid1=(la+ua)/<span class="number">2</span>;</span><br><span class="line">mid2=(lb+ub+<span class="number">1</span>)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这样的意思是若出现一个偶数组一个奇数组，得到的中间位置一样。</p>
<p>因为保证两数组长度一样，会出现数组只有两个的情况，如果按上面的方法会出现</p>
<p><img src="/2021/09/30/9-30%E5%85%B3%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E6%B2%BB%E4%B9%8B%E9%A2%98/test.jpg"></p>
<p>造成死循环。所以进行处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mid1=(la+ua)/<span class="number">2</span>;</span><br><span class="line">mid2=(lb+ub)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这样处理的都是0位置元素</p>
<p>递归终止条件</p>
<p>当两个数组都只有一个元素的时候，中位数肯定就是小的那一个。</p>
<p>经过上述两个元素数组的处理，会出现一种类型的情况，a数组有1个元素，b数组有2个元素，意味着a的元素大于b的第一个元素，按中位数的定义，比较b的第二个元素和a，小的那个就是中位数。同理a,b调换。</p>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">int</span> la,<span class="keyword">int</span> ua,<span class="keyword">int</span> lb,<span class="keyword">int</span> ub)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid1=(la+ua)/<span class="number">2</span>,mid2=(lb+ub+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(la==ua&amp;&amp;lb!=ub)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[la]&gt;b[ub])&#123;</span><br><span class="line">			<span class="keyword">return</span> b[ub];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a[la];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(la!=ua&amp;&amp;lb==ub)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[ua]&lt;b[ub])&#123;</span><br><span class="line">			<span class="keyword">return</span> a[ua];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b[ub];</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">if</span>(la==ua&amp;&amp;lb==ub)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[la]&gt;b[lb])&#123;</span><br><span class="line">			<span class="keyword">return</span> b[lb];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a[la];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(la+<span class="number">1</span>==ua&amp;&amp;lb+<span class="number">1</span>==ub)&#123;</span><br><span class="line">			mid1=(la+ua)/<span class="number">2</span>;</span><br><span class="line">			mid2=(lb+ub)/<span class="number">2</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span>(a[mid1]==b[mid2])&#123;</span><br><span class="line">			<span class="keyword">return</span> a[mid1];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a[mid1]&lt;b[mid2])&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">binary</span>(mid1,ua,lb,mid2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a[mid1]&gt;b[mid2])&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">binary</span>(la,mid1,mid2,ub);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">binary</span>(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法心得</tag>
      </tags>
  </entry>
  <entry>
    <title>DS-ch6</title>
    <url>/2021/05/23/DS-ch6/</url>
    <content><![CDATA[<h1 id="DS-ch6"><a href="#DS-ch6" class="headerlink" title="DS-ch6"></a>DS-ch6</h1><p>图论的算法包括</p>
<ul>
<li>图的存储方式</li>
<li>邻接矩阵</li>
<li>邻接表</li>
<li>图的遍历</li>
<li>深度优先搜索（dfs）</li>
<li>广度优先搜索（bfs）</li>
<li><span id="more"></span></li>
<li>图的应用</li>
<li>最小生成树</li>
<li>普利姆算法（从一棵小树长大）</li>
<li>克鲁斯卡尔算法（选择最小边）</li>
<li>最短路径</li>
<li>迪杰斯特拉算法（单源最短路）</li>
<li>弗洛伊德算法（多源最短路）</li>
</ul>
<h2 id="L3天梯赛——地铁一日游"><a href="#L3天梯赛——地铁一日游" class="headerlink" title="L3天梯赛——地铁一日游"></a>L3天梯赛——地铁一日游</h2><p>这道题看题解看了一上午才终于似懂非懂，由于魔都的地铁路线是以两点的最短路计费，所以当然要求最短路径，并且是多源有权图的最短路径，所以用弗洛伊德算法。这个森森，他要选择相同计费前提下距离最远的站点或者线路末端拍照，所以需要一个map，记录相同费用下的最大距离(map[‘一个费用’]=’最大距离’)，当出发点到这个结点(mp [i] [j])的距离是等于这个最大距离的时候，或者此结点本身是线路末端的时候，把它放进一个vector（res）保存，方便dfs的时候遍历标记，需要注意，当他出去站点的时候，他还可以再进来，再重新选择相同费用的最大距离的站点，所以用dfs。</p>
<p>思路如下：</p>
<p>对于每个结点创建一个结构体保存它在每个相同费用下能够达到的结点，ends表示它是否为末端，visit表示现在是由哪个结点出发</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">station</span>&#123;</span>    </span><br><span class="line">	<span class="keyword">int</span> visit,ends;    </span><br><span class="line">	<span class="built_in">station</span>()&#123;        </span><br><span class="line">		visit=ends=<span class="number">0</span>;    </span><br><span class="line">	&#125;    </span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; res;*<span class="comment">//所有可到达的站* </span></span><br><span class="line">&#125;sta[MAX];</span><br></pre></td></tr></table></figure>

<p>mp [i] [j]存放从i到j的最短路径，初始化时有边相连则赋值权重，无边的时候则赋最大值。之后用弗洛伊德算法的三重循环使mp[i] [j]存的是最短路</p>
<figure class="highlight plaintext"><figcaption><span>floyed()&#123;//Floyed求最短路径</span></figcaption><table><tr><td class="code"><pre><span class="line">void floyed()&#123;//Floyed求最短路径    </span><br><span class="line">    for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">                if(i!=j&amp;&amp;mp[i][j]&gt;mp[i][k]+mp[k][j])&#123;</span><br><span class="line">                    mp[i][j]=mp[i][k]+mp[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着计算可能产生的费用，mp[i] [j]/k+2作为map<int> <int> m1的键，遍历结点，找出i相应费用的最大距离，当从i到j的距离是费用的最大距离或者j是末端点，则把j放入i的res数组中</int></int></p>
<figure class="highlight plaintext"><figcaption><span>i</span></figcaption><table><tr><td class="code"><pre><span class="line">for(int i=1;i&lt;=n;i++)&#123;//对于每个站而言，寻找每个费用的最远距离,并将结果存入res中</span><br><span class="line">        map&lt;int,int&gt; m1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(mp[i][j]!=INF&amp;&amp;mp[i][j]&gt;m1[mp[i][j]/k+2])&#123;</span><br><span class="line">                m1[mp[i][j]/k+2]=mp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            if(mp[i][j]==m1[mp[i][j]/k+2]||(i!=j&amp;&amp;mp[i][j]!=INF&amp;&amp;sta[j].ends==1))			&#123;</span><br><span class="line">               sta[i].res.push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输入森森打算出发的结点i，并且dfs i的res数组，把它能够到的结点打上标记</p>
<figure class="highlight plaintext"><figcaption><span>dfs(int i,int vis)&#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">void dfs(int i,int vis)&#123;</span><br><span class="line">for(int j=0;j&lt;sta[i].res.size();j++)&#123;</span><br><span class="line">        int t=sta[i].res[j];</span><br><span class="line">        if(sta[t].visit!=vis)&#123;</span><br><span class="line">            sta[t].visit=vis;</span><br><span class="line">            dfs(t,vis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次遍历结点，若标点为出发点，则将它输出即可</p>
<p>我太菜了</p>
<h2 id="L3-014-周游世界-30-分"><a href="#L3-014-周游世界-30-分" class="headerlink" title="L3-014 周游世界 (30 分)"></a>L3-014 周游世界 (30 分)</h2><p>dfs+回溯</p>
<p>用一个结构体数组存储一个结点的相邻节点和所属公司的信息。从一个结点出发，通过遍历这个结点编号的数组就可以得到它的下一个站点和公司信息，因为有的站点有可能是换乘站，所以它数组元素不止一个，注意双向存储，因为线路是双向的。dfs传递的参数站点数量，公司数量，以及它前一个公司的编号，因为要通过公司编号判断是否是换乘。如果不是换乘，则直接递归下一站，如果是换乘，则需要把换乘站（包括起点）压入一个数组中，当前公司编号也要压入数组中。本题是dfs递归+回溯，通过回溯不断更新最少站点和最少换乘站，可以找到最终结果。</p>
<p>最难的回溯部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> snum,<span class="keyword">int</span> cnum,<span class="keyword">int</span> com)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a==en)&#123;</span><br><span class="line">		<span class="keyword">if</span>(stationnum&gt;snum||stationnum==snum&amp;&amp;cnum&lt;companynum)&#123;</span><br><span class="line">			stationnum=snum;</span><br><span class="line">			companynum=cnum;</span><br><span class="line">			path=t1;</span><br><span class="line">			companypath=t2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec[a].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[vec[a][i].next])&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[vec[a][i].next]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(vec[a][i].company==com)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(vec[a][i].next,snum+<span class="number">1</span>,cnum,com);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			t1.<span class="built_in">push_back</span>(a);</span><br><span class="line">			t2.<span class="built_in">push_back</span>(vec[a][i].company);</span><br><span class="line">			<span class="built_in">dfs</span>(vec[a][i].next,snum+<span class="number">1</span>,cnum+<span class="number">1</span>,vec[a][i].company);</span><br><span class="line">			t1.<span class="built_in">pop_back</span>();</span><br><span class="line">			t2.<span class="built_in">pop_back</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		vis[vec[a][i].next]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种算法应该写起来最简单了，咋一看像最短路问题，我太菜了</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+icarus</title>
    <url>/2021/10/02/Hexo-icarus/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的matery主题因为上传图片失败拖了几个月没有管，这次写了篇分治想重新上传，按照教程下载hexo-asset-image，其实已经下载成功了，却因为事隔太久看到warn误以为失败，加上预览的时候加载不到图片（当时不知道是它自己的bug），就根据错误瞎折腾。也不知道修改了什么，居然连渲染页面都不能用，当时只觉得很奇怪，也没有debug。我怀疑码云上的网站和仓库断开了，确定代码推送到仓库但网页还是以前一样。matery的风格也和本校同学冲撞了，而且看起来花里胡哨，干脆再做一个。然而因为权限问题删除原文件夹删了半天，把权限从everyone到本地账户改来改去都不行，最后直接移到program file删了。本来使用next，以为很简单的事预览的时候网页只显示</p>
<p><code>&#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;</code></p>
<span id="more"></span>

<p>原来是hexo在5.0之后把swig给删除了需要自己手动安装：</p>
<p><code>npm install hexo-renderer-swig</code></p>
<p>之后分类页，标签页已经创建了然而网页还是404。干脆不搞了，对hexo产生了畏惧心理。之前没有总结建博客，现在认真记一些</p>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="预备环境"><a href="#预备环境" class="headerlink" title="预备环境"></a>预备环境</h2><ul>
<li>git</li>
<li>github账号</li>
<li>node.js以及npm</li>
</ul>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p><code>npm install -g hexo-cli</code></p>
<p><code>cd</code>到想要放置项目的目录，打开git</p>
<p><code>hexo init blog</code> </p>
<p><code>cd</code> 到<code>blog</code></p>
<p><code>npm install</code></p>
<p>接着就可以<code>hexo s</code>看看效果了，打开<code>http://localhost:4000</code></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b26252eb40bc11f27ab2808484f82dd0.png"></p>
<p>hexo常用命令：</p>
<ul>
<li><p>清理下：<code>hexo clean</code></p>
</li>
<li><p>生成下：<code>hexo g</code></p>
</li>
<li><p>启动下：<code>hexo s</code></p>
</li>
<li><p>新建文章：<code>hexo new &quot;文件名&quot;</code></p>
</li>
<li><p>部署：<code>hexo d</code></p>
</li>
</ul>
<p>部署到github上：<code>npm install --save hexo-deployer-git</code></p>
<p>在blog目录下打开<code>_config.yml</code>，hexo全局配置文件，修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:risotoonero/risotoonero.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>记得title和author写上自己的，然后<code>hexo d</code>就可以在github上看到效果。</p>
<h1 id="icarus主题"><a href="#icarus主题" class="headerlink" title="icarus主题"></a>icarus主题</h1><p><code>git clone https://github.com/ppoffice/hexo-theme-icarus themes/icarus </code></p>
<p>更改<code>_config.yml</code>中的theme，hexo升级后有点奇怪，它的配置文件在blog下的<code>_config.icarus.yml</code>。这样还不能马上看到效果，可能是icarus需要相关依赖：</p>
<p><img src="/2021/10/02/Hexo-icarus/0.jpg"></p>
<p><code> npm install --save bulma-stylus@0.8.0 hexo-component-inferno@^0.4.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3</code></p>
<p>安装成功的结果是这样的，别再搞乌龙了</p>
<p><img src="/2021/10/02/Hexo-icarus/1.jpg"></p>
<p>结果安装版本不对</p>
<p><img src="/2021/10/02/Hexo-icarus/2.jpg"></p>
<p><code>npm install --save hexo-component-inferno@^0.13.0</code></p>
<h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><p><code>npm install hexo-asset-image --save</code></p>
<p>修改<code>_config.yml</code>的<code>post_asset_folder</code>改为<code>true</code></p>
<p>在new了一篇文章后可以看到除了.md还有一个同名的文件夹，那是用来存图片的，文章中的图片路径名可以用<code>文件名/图片名</code>，就是在这里试来试去都不成功，心态都崩了，后面反应过来了是该死的文件路径出错了：</p>
<p><img src="/2021/10/02/Hexo-icarus/3.jpg"></p>
<p>io是什么呢，小编也很异或，上网一查</p>
<p><a href="https://github.com/xcodebuild/hexo-asset-image/issues/47">hexo-asset-image的bug</a></p>
<p>解决方案</p>
<p><img src="/2021/10/02/Hexo-icarus/4.jpg"></p>
<p><code>link = link.substring(beginPos, endPos) + &#39;/&#39; + appendLink</code></p>
<p><code>var endPos = link.length-1; </code></p>
<p>接下来就是主题配置的问题了，部分的配置信息如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Version of the Icarus theme that is currently used</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">2.3</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/images/favicons.ico</span></span><br><span class="line"><span class="comment"># Path or URL to RSS atom.xml</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br><span class="line"><span class="comment"># 显示在导航栏左侧的网站logo，同样可以自己制作</span></span><br><span class="line"><span class="attr">logo:</span> <span class="string">/images/gen.svg</span></span><br><span class="line"><span class="comment"># Open Graph metadata</span></span><br><span class="line"><span class="comment"># https://hexo.io/docs/helpers.html#open-graph</span></span><br><span class="line"><span class="attr">open_graph:</span></span><br><span class="line">    <span class="comment"># Facebook App ID</span></span><br><span class="line">    <span class="attr">fb_app_id:</span> </span><br><span class="line">    <span class="comment"># Facebook Admin ID</span></span><br><span class="line">    <span class="attr">fb_admins:</span> </span><br><span class="line">    <span class="comment"># Twitter ID</span></span><br><span class="line">    <span class="attr">twitter_id:</span> </span><br><span class="line">    <span class="comment"># Twitter site</span></span><br><span class="line">    <span class="attr">twitter_site:</span> </span><br><span class="line">    <span class="comment"># Google+ profile link</span></span><br><span class="line">    <span class="attr">google_plus:</span> </span><br><span class="line"><span class="comment">#  导航栏</span></span><br><span class="line"><span class="attr">navbar:</span></span><br><span class="line">    <span class="comment">#菜单（显示名称：对应文件夹）</span></span><br><span class="line">    <span class="attr">menu:</span></span><br><span class="line">        <span class="string">主页:</span> <span class="string">/</span></span><br><span class="line">        <span class="string">归档:</span> <span class="string">/archives</span></span><br><span class="line">        <span class="string">分类:</span> <span class="string">/categories</span></span><br><span class="line">        <span class="string">标签:</span> <span class="string">/tags</span></span><br><span class="line">        <span class="string">关于:</span> <span class="string">/about</span>   </span><br><span class="line">    <span class="comment"># 导航栏右侧图标链接</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">        <span class="attr">My GitHub:</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">&#x27;你的gityhub地址&#x27;</span></span><br><span class="line"><span class="comment"># Footer section link settings</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">    <span class="comment"># 页脚图标链接</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">        <span class="attr">Creative Commons:</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-creative-commons</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">&#x27;https://creativecommons.org/&#x27;</span></span><br><span class="line">        <span class="attr">Attribution 4.0 International:</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-creative-commons-by</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">&#x27;https://creativecommons.org/licenses/by/4.0/&#x27;</span></span><br><span class="line">        <span class="attr">Download on GitHub:</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">&#x27;http://github.com/ppoffice/hexo-theme-icarus&#x27;</span></span><br><span class="line"><span class="comment"># 文章显示设置</span></span><br><span class="line"><span class="attr">article:</span></span><br><span class="line">    <span class="comment"># Code highlight theme</span></span><br><span class="line">    <span class="comment"># https://github.com/highlightjs/highlight.js/tree/master/src/styles</span></span><br><span class="line">    <span class="comment">#代码主题atom-one-light亮色，atom-one-dark暗色</span></span><br><span class="line">    <span class="attr">highlight:</span> <span class="string">atom-one-dark</span></span><br><span class="line">    <span class="comment"># 是否显示文章主图</span></span><br><span class="line">    <span class="attr">thumbnail:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否显示估算阅读时间</span></span><br><span class="line">    <span class="attr">readtime:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 搜索插件设置</span></span><br><span class="line"><span class="comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Plugins</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">    <span class="comment"># Name of the search plugin</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">insight</span></span><br><span class="line"><span class="comment"># 评论插件设置</span></span><br><span class="line"><span class="comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Plugins</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">    <span class="comment">#可选valine，disqus（科学上网）等</span></span><br><span class="line">    <span class="comment"># Name of the comment plugin</span></span><br><span class="line">    <span class="comment">#type: valine</span></span><br><span class="line">    <span class="comment">#app_id: 不为空</span></span><br><span class="line">    <span class="comment">#app_key: 不为空</span></span><br><span class="line">    <span class="comment">#notify: true</span></span><br><span class="line">    <span class="comment">#verify: true</span></span><br><span class="line">    <span class="comment">#placeholder:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">disqus</span></span><br><span class="line">    <span class="attr">shortname:</span> <span class="string">不能为空</span></span><br><span class="line"><span class="comment"># 打赏功能</span></span><br><span class="line"><span class="comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/</span></span><br><span class="line"><span class="attr">donate:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 阿里巴巴支付宝</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">alipay</span></span><br><span class="line">        <span class="comment"># 二维码图片</span></span><br><span class="line">        <span class="attr">qrcode:</span> <span class="string">&#x27;/images/honbao.PNG&#x27;</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 微信</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">wechat</span></span><br><span class="line">        <span class="comment"># 二维码图片</span></span><br><span class="line">        <span class="attr">qrcode:</span> <span class="string">&#x27;/images/yjtp.png&#x27;</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line"><span class="comment"># 分享插件设置</span></span><br><span class="line"><span class="comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Plugins</span></span><br><span class="line"><span class="attr">share:</span></span><br><span class="line">    <span class="comment"># 插件类型，有多种，可选，自行百度</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">sharejs</span></span><br><span class="line"><span class="comment"># Sidebar settings.</span></span><br><span class="line"><span class="comment"># Please be noted that a sidebar is only visible when it has at least one widget</span></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">    <span class="comment"># 左侧边栏设置</span></span><br><span class="line">    <span class="attr">left:</span></span><br><span class="line">        <span class="comment"># 是否不随页面滚动</span></span><br><span class="line">        <span class="comment"># http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line">        <span class="attr">sticky:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 右侧边栏设置</span></span><br><span class="line">    <span class="attr">right:</span></span><br><span class="line">        <span class="comment"># 是否不随页面滚动</span></span><br><span class="line">        <span class="comment"># http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/</span></span><br><span class="line">        <span class="attr">sticky:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 边栏小部件设置</span></span><br><span class="line"><span class="comment"># http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 个人信息</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">profile</span></span><br><span class="line">        <span class="comment"># 部件位置（左）</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">        <span class="comment"># 作者名（字符串）</span></span><br><span class="line">        <span class="attr">author:</span> <span class="string">飞鱼</span></span><br><span class="line">        <span class="comment"># 作者身份描述（字符串）</span></span><br><span class="line">        <span class="attr">author_title:</span> <span class="string">Student</span></span><br><span class="line">        <span class="comment"># 作者当前居住地</span></span><br><span class="line">        <span class="attr">location:</span> <span class="string">China,Fujian</span></span><br><span class="line">        <span class="comment"># 头像（可用本地图片或网络图片链接）</span></span><br><span class="line">        <span class="attr">avatar:</span> <span class="string">&#x27;/images/ava.png&#x27;</span></span><br><span class="line">        <span class="comment"># Email address for the Gravatar to be shown in the profile widget</span></span><br><span class="line">        <span class="attr">gravatar:</span> </span><br><span class="line">        <span class="comment"># 关注我的链接，可设为你的GitHub主页</span></span><br><span class="line">        <span class="attr">follow_link:</span> <span class="string">&#x27;https://github.com/yourname&#x27;</span></span><br><span class="line">        <span class="comment"># 个人介绍部件底部图标社交链接</span></span><br><span class="line">        <span class="attr">social_links:</span></span><br><span class="line">            <span class="attr">Github:</span></span><br><span class="line">                <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">&#x27;https://github.com/yourname&#x27;</span></span><br><span class="line">            <span class="attr">Facebook:</span></span><br><span class="line">                <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-facebook</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">&#x27;https://facebook.com&#x27;</span></span><br><span class="line">            <span class="attr">Twitter:</span></span><br><span class="line">                <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-twitter</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">&#x27;https://twitter.com/yourname&#x27;</span></span><br><span class="line">            <span class="attr">RSS:</span></span><br><span class="line">                <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-rss</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># Widget name</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">toc</span></span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 分类</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">category</span></span><br><span class="line">        <span class="comment"># 位置指定</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 标签云</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">tagcloud</span></span><br><span class="line">        <span class="comment"># 位置</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 近期文章</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">recent_posts</span></span><br><span class="line">        <span class="comment"># 位置</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 归档</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">archive</span></span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 标签</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">tag</span></span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="comment"># 外部链接</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">links</span></span><br><span class="line">        <span class="comment"># Where should the widget be placed, left or right</span></span><br><span class="line">        <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">        <span class="comment"># Links to be shown in the links widget</span></span><br><span class="line">        <span class="attr">links:</span></span><br><span class="line">            <span class="attr">Google:</span> <span class="string">&#x27;https://google.com&#x27;</span></span><br><span class="line">            <span class="attr">Baidu:</span> <span class="string">&#x27;https://baidu.com&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意图片一定要放在theme的img下才能找到</p>
<h2 id="页面点击出现爱心"><a href="#页面点击出现爱心" class="headerlink" title="页面点击出现爱心"></a>页面点击出现爱心</h2><p>在<code>\blog\themes\icarus\source\js</code>下，新建<code>clicklove.js</code>，写入以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),</span><br><span class="line">        o(),</span><br><span class="line">        r()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)</span><br><span class="line">            d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;</span><br><span class="line">        e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            t&amp;&amp;t(),i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">            a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX-<span class="number">5</span>,<span class="attr">y</span>:e.clientY-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(t)&#123;</span><br><span class="line">            a.styleSheet.cssText=e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> d=[];</span><br><span class="line">    e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(),</span><br><span class="line">    n()</span><br><span class="line">&#125;</span><br><span class="line">(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<p>修改<code>layout.ejs</code>，找到<code>\blog\themes\icarus\layout\layout.ejs</code>,添加：</p>
<script src="js/clicklove.js"></script>
<h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><p>在文章开头加上<code>toc: true</code></p>
<h2 id="板娘"><a href="#板娘" class="headerlink" title="板娘"></a>板娘</h2><p>板娘很奇怪，我想要只猫，但换了两个模型都是那个女孩，匪夷所思。</p>
<p><code>npm install hexo-helper-live2d --save</code></p>
<p>在主题配置文件加上一段</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                                   <span class="comment">#开启看板娘</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-tororo</span>     <span class="comment">#指定模型任务</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span>                              <span class="comment">#显示位置</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">200</span>                                   <span class="comment">#模型宽度</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">400</span>                                  <span class="comment">#模型高度</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="评论插件"><a href="#评论插件" class="headerlink" title="评论插件"></a>评论插件</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">valine</span></span><br><span class="line"><span class="attr">app_id:</span> </span><br><span class="line">   <span class="attr">app_key:</span> </span><br><span class="line">   <span class="attr">notify:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">verify:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">placeholder:</span></span><br></pre></td></tr></table></figure>

<p>遇到这些报错就是主题文件配置错误，应该要自己找到</p>
<p><img src="/2021/10/02/Hexo-icarus/5.jpg"></p>
<h1 id="我遇到的问题"><a href="#我遇到的问题" class="headerlink" title="我遇到的问题"></a>我遇到的问题</h1><ol>
<li>把widgets放在右边无效，只能全部在左边</li>
<li><code>article</code>的<code>thumbnail: true</code>无效，文章<code>thumbnail</code>的路径设为<code>/2021/09/30/9-30关于排序和分治之题/0.jpg</code>才访问得到，只有缩略图，主页的文章封面没有，更不用说banner连图片都没有。想着每次写文章都要准备一张封面挺麻烦，而且博客简洁点就好，就算了。</li>
</ol>
<p>public文件夹是网页呈现的东西</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树 II</title>
    <url>/2021/10/16/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II/</url>
    <content><![CDATA[<h1 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II</a></h1><h2 id="无解的解法一：回溯"><a href="#无解的解法一：回溯" class="headerlink" title="无解的解法一：回溯"></a>无解的解法一：回溯</h2><p>之前的回溯有两个错误，一是只能产生单支树，根结点为1或3的时候没发现，为2的时候就发现了[[2,1,null,null,3],[2,null,3,1,null]]，因为我的递归有问题；二是不知为什么，比如[[1,null,2,null,3],[1,null,3,2]]之后，会出现[1,null,3]这样的诡异结果。</p>
<p>其实再早之前的回溯也有很大的问题，只能出现一种解的原因是第一种解出现，结点上就有值，就不能把第二解赋给结点，起初以为放入vector之后，把head-&gt;left，head-&gt;right置空就行，然而head是指针，置空的话就会把原来放入vector的值都置空了，无奈只能新建一棵树h，把head复制进h，再把head置空。然后出现上述的情形。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(TreeNode* t,TreeNode* &amp;newt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            newt = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            newt = <span class="keyword">new</span> TreeNode;</span><br><span class="line">            newt-&gt;val = t-&gt;val;</span><br><span class="line">            <span class="built_in">Copy</span>(t-&gt;left,newt-&gt;left);</span><br><span class="line">            <span class="built_in">Copy</span>(t-&gt;right,newt-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">digui</span><span class="params">(TreeNode* &amp;head,TreeNode* &amp;tree,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(!tree)&#123;</span><br><span class="line">            TreeNode* tree1=<span class="keyword">new</span> TreeNode;</span><br><span class="line">            tree1-&gt;val=i;</span><br><span class="line">            tree1-&gt;left=tree1-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">            tree=tree1;</span><br><span class="line">            a[i]=<span class="number">1</span>;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(j==n)&#123;</span><br><span class="line">                TreeNode* h=<span class="literal">nullptr</span>;</span><br><span class="line">                <span class="built_in">Copy</span>(head,h);</span><br><span class="line">                v.<span class="built_in">push_back</span>(h);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k==head-&gt;val)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">                head-&gt;right=<span class="literal">nullptr</span>;              </span><br><span class="line">                <span class="keyword">return</span> ;        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=n;p++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[p]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">digui</span>(head,tree,p,j,n);	</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;tree-&gt;val)&#123;</span><br><span class="line">            <span class="built_in">digui</span>(head,tree-&gt;left,i,j,n);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;tree-&gt;val)&#123;</span><br><span class="line">            <span class="built_in">digui</span>(head,tree-&gt;right,i,j,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>现在改进了一下回溯，在赋值给根结点（j==1）之后进入递归，j&gt;=1时return，这样就避免了单支树情况。但是这样又有了新的问题，那就是，比如根结点为1时，只能解出1，2，3的顺序，而没有1，3，2的顺序，因为直接return的时候循环也遍历完了。所以再改进，回溯的最终代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    vector&lt;TreeNode*&gt; v;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(TreeNode* t,TreeNode* &amp;newt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            newt = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            newt = <span class="keyword">new</span> TreeNode;</span><br><span class="line">            newt-&gt;val = t-&gt;val;</span><br><span class="line">            <span class="built_in">Copy</span>(t-&gt;left,newt-&gt;left);</span><br><span class="line">            <span class="built_in">Copy</span>(t-&gt;right,newt-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">digui</span><span class="params">(TreeNode* &amp;head,TreeNode* &amp;tree,<span class="keyword">int</span> i,<span class="keyword">int</span> &amp;j,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tree)&#123;</span><br><span class="line">            TreeNode* tree1=<span class="keyword">new</span> TreeNode;</span><br><span class="line">            tree1-&gt;val=i;</span><br><span class="line">            tree1-&gt;left=tree1-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">            tree=tree1;</span><br><span class="line">            a[i]=<span class="number">1</span>;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(j==n)&#123;</span><br><span class="line">                TreeNode* h=<span class="literal">nullptr</span>;</span><br><span class="line">                <span class="built_in">Copy</span>(head,h);</span><br><span class="line">                v.<span class="built_in">push_back</span>(h);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k==head-&gt;val)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[k]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                head-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">                head-&gt;right=<span class="literal">nullptr</span>; </span><br><span class="line">                j=<span class="number">1</span>;              </span><br><span class="line">                <span class="keyword">return</span> ;        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[u]==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">digui</span>(head,tree,u,j,n);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=n;p++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(a[p]==<span class="number">0</span>&amp;&amp;p!=u)&#123;</span><br><span class="line">                                <span class="built_in">digui</span>(head,tree,p,j,n);                         </span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;tree-&gt;val)&#123;</span><br><span class="line">            <span class="built_in">digui</span>(head,tree-&gt;left,i,j,n);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;tree-&gt;val)&#123;</span><br><span class="line">            <span class="built_in">digui</span>(head,tree-&gt;right,i,j,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;      </span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">            TreeNode* tree=<span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">digui</span>(tree,tree,i,j,n);          </span><br><span class="line">            i++;  </span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                a[k]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最终的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1,null,2,null,3],[1,null,3,2],[2,1,3],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure>

<p>回溯的时候无可避免地出现了重复的结果，比如2，1，3和2，3，1的结果是一样的。所以我的回溯最终的结果只能到这里。虽然行不通，但做题的过程中学到了许多，而且花费的时间也很多。看题解采用的是二叉搜索树的特点和递归。</p>
<h2 id="官方解法二：递归"><a href="#官方解法二：递归" class="headerlink" title="官方解法二：递归"></a>官方解法二：递归</h2><p>递归，leetcode官方解法说是回溯，我不知道哪里有回溯</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; v1;</span><br><span class="line">        vector&lt;TreeNode*&gt; v2;</span><br><span class="line">        vector&lt;TreeNode*&gt; v3;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;=n;i++)&#123;</span><br><span class="line">            v1=<span class="built_in">generate</span>(m,i<span class="number">-1</span>);</span><br><span class="line">            v2=<span class="built_in">generate</span>(i+<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> tree:v1)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> tree2:v2)&#123;</span><br><span class="line">                        TreeNode* t=<span class="keyword">new</span> TreeNode;</span><br><span class="line">                        t-&gt;val=i;</span><br><span class="line">                        t-&gt;left=tree;</span><br><span class="line">                        t-&gt;right=tree2;</span><br><span class="line">                        v3.<span class="built_in">push_back</span>(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generate</span>(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为 n，如果我们枚举根节点的值为 i，那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 <code>[1…i−1]</code>，右子树的节点值的集合为 <code>[i+1…n]</code>。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题。</p>
<p>我们定义 <code>generate(start, end)</code> 函数表示当前值的集合为 <code>[start,end]</code>，返回序列<code>[start,end]</code> 生成的所有可行的二叉搜索树。按照上文的思路，我们考虑枚举 <code>[start,end] </code>中的值 ii 为当前二叉搜索树的根，那么序列划分为了<code>[start,i−1] </code>和 <code>[i+1,end] </code>两部分。我们递归调用这两部分，即 <code>generateTrees(start, i - 1) </code>和<code> generateTrees(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，那么最后一步我们只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p>
<p>递归的入口即为 <code>generateTrees(1, n)</code>，出口为当 <code>start&gt;end</code> 的时候，当前二叉搜索树为空，返回空节点即可。</p>
<h2 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">clone</span><span class="params">(TreeNode* tree2,<span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tree2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* tree3=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(tree2-&gt;val+offset);</span><br><span class="line">        tree3-&gt;left=<span class="built_in">clone</span>(tree2-&gt;left,offset);</span><br><span class="line">        tree3-&gt;right=<span class="built_in">clone</span>(tree2-&gt;right,offset);</span><br><span class="line">        <span class="keyword">return</span> tree3;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;TreeNode*&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="literal">nullptr</span>&#125;);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=n;len++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> root=<span class="number">1</span>;root&lt;=len;root++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left=root<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> right=len-root;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; tree1:dp[left])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; tree2:dp[right])&#123;</span><br><span class="line">                        TreeNode* tree=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(root);</span><br><span class="line">                        tree-&gt;left=tree1;</span><br><span class="line">                        tree-&gt;right=<span class="built_in">clone</span>(tree2,root);</span><br><span class="line">                        dp[len].<span class="built_in">push_back</span>(tree);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一次报错数组为空是因为<code>vector</code>二维数组初始化问题，需要写上<code>v(n+1)</code>才可。</p>
<p>动态规划的思想是从元素个数入手，先算出个数为1的所有树，个数为2的所有树….直到n。对于每一个长度的树，遍历根结点，根结点为3的树，它的左子树的元素都比它小（1、2），所以加上个数为2的所有可能性；根结点为2的树，左子树元素为1，因此加上个数为1的所有子树，同理右子树。采用自底向上的方法。可以观察到所有长度为2的树（1、2；2、1）和（2，3；3，2）只是元素数值不相同，结构是一样的。所以没必要再求一次，只需要把长度为2的树克隆一份，加上根结点的值即可，同理长度为n的也一样。可以参考题解：</p>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-2-7/">解法三</a></p>
<h2 id="解法四：动态规划"><a href="#解法四：动态规划" class="headerlink" title="解法四：动态规划"></a>解法四：动态规划</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; pre = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//每次增加一个数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; cur = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//遍历之前的所有解</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode root : pre) &#123;</span><br><span class="line">            <span class="comment">//插入到根节点</span></span><br><span class="line">            TreeNode insert = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">            insert.left = root;</span><br><span class="line">            cur.add(insert);</span><br><span class="line">            <span class="comment">//插入到右孩子，右孩子的右孩子...最多找 n 次孩子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                TreeNode root_copy = treeCopy(root); <span class="comment">//复制当前的树</span></span><br><span class="line">                TreeNode right = root_copy; <span class="comment">//找到要插入右孩子的位置</span></span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//遍历 j 次找右孩子</span></span><br><span class="line">                <span class="keyword">for</span> (; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (right == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    right = right.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//到达 null 提前结束</span></span><br><span class="line">                <span class="keyword">if</span> (right == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//保存当前右孩子的位置的子树作为插入节点的左孩子</span></span><br><span class="line">                TreeNode rightTree = right.right;</span><br><span class="line">                insert = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                right.right = insert; <span class="comment">//右孩子是插入的节点</span></span><br><span class="line">                insert.left = rightTree; <span class="comment">//插入节点的左孩子更新为插入位置之前的子树</span></span><br><span class="line">                <span class="comment">//加入结果中</span></span><br><span class="line">                cur.add(root_copy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">treeCopy</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode newRoot = <span class="keyword">new</span> TreeNode(root.val);</span><br><span class="line">    newRoot.left = treeCopy(root.left);</span><br><span class="line">    newRoot.right = treeCopy(root.right);</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">copy</span><span class="params">(TreeNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* newtree=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(head-&gt;val);</span><br><span class="line">        newtree-&gt;left=<span class="built_in">copy</span>(head-&gt;left) ;</span><br><span class="line">        newtree-&gt;right=<span class="built_in">copy</span>(head-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> newtree;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; pre;</span><br><span class="line">        </span><br><span class="line">        pre.<span class="built_in">push_back</span>(&#123;<span class="literal">nullptr</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            vector&lt;TreeNode*&gt; now;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t:pre)&#123;</span><br><span class="line">                TreeNode* tree=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                tree-&gt;left=t;</span><br><span class="line">                now.<span class="built_in">push_back</span>(tree);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;<span class="comment">//从0开始，因为根结点右边也可以加</span></span><br><span class="line">                    TreeNode* t4=<span class="built_in">copy</span>(t);<span class="comment">//在j这个循环中如果不复制t就会被改变</span></span><br><span class="line">                    TreeNode* t1=t4;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;<span class="comment">//(注意这里不能写成k&lt;=j,因为循环了j次之后t1会到达nullptr，直接break，无法在右子树插入新结点，结果只有根结点)</span></span><br><span class="line">                        <span class="keyword">if</span>(t1==<span class="literal">NULL</span>)&#123;<span class="comment">//Line 40: Char 32: runtime error: member access within null pointer of type &#x27;TreeNode&#x27; (solution.cpp)(t1-&gt;right==NULL报错)</span></span><br><span class="line">SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:<span class="number">49</span>:<span class="number">32</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        t1=t1-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!t1)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    TreeNode* t3=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    TreeNode* tmp=t1-&gt;right;</span><br><span class="line">                    t1-&gt;right=t3;</span><br><span class="line">                    t3-&gt;left=tmp;</span><br><span class="line">                    now.<span class="built_in">push_back</span>(t4);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>数学之美第5章</title>
    <url>/2021/10/13/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="隐含马尔可夫模型"><a href="#隐含马尔可夫模型" class="headerlink" title="隐含马尔可夫模型"></a>隐含马尔可夫模型</h1><h2 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h2><p>语音识别，机器翻译，文本纠错，都是根据发送者传送的一串信息s1,s2,…st经过一定的编码方式o1,o2,..,ot传送到接收者，接收者解码还原为s1,s2,..st。要从接收到的信息还原，只需要在原数据中找出最可能产生o1,o2,..ot的那串信息即可。用概率论表述，在已知o1,o2,..ot的情况下，求使P(s1,s2,…st|o1,o2,..,ot)最大的信息串s1,s2,…st：<br>$$<br>s1,s2,..st=ArgMax  P(s1,s2,…st|o1,o2,..,ot)<br>$$<br>ArgMax表示能获得最大值的那个参数argument。</p>
<p>P(s1,s2,…st|o1,o2,..,ot)使用贝叶斯变换得到：<br>$$<br>P(s1,s2,…st|o1,o2,..,ot)=\frac{P(o1,o2,..,ot|s1,s2,…st)*P(s1,s2,…st)}{P(o1,o2,..,ot)}<br>(5.5)<br>$$<br>由于P(o1,o2,..,ot)已经确定，所以它可以作为一个常数，只需要计算上面的部分。</p>
<span id="more"></span>

<h2 id="隐含马尔可夫模型-1"><a href="#隐含马尔可夫模型-1" class="headerlink" title="隐含马尔可夫模型"></a>隐含马尔可夫模型</h2><p>每一个状态St出现的概率，都与上一次的状态St-1有关。根据转移概率，可以由当前的状态计算出下一个状态的概率。即P(St|St-1,St-2,…,S1)=P(St|St-1)。隐含马尔可夫模型是马尔可夫链的一个扩展，每一个状态St是不可见的，所以没法计算出转移概率，但是看得见一个独立输出假设Ot，仅仅与St有关。St即发送者原信号，Ot即接收端接收到的信号。我们可以计算出出现每个输出假设的概率：<br>$$<br>P(s1,s2,…,o1,o2,..,ot)=\prod_{t}P(St|St-1)*P(Ot|St)<br>(5.6)<br>$$<br>P(St|St-1)表示状态St出现的概率，P(Ot|St)表示根据St能产生Ot的概率。</p>
<p>其中<br>$$<br>P(o1,o2,..,ot|s1,s2,…st)=\prod_{t}P(Ot|St)<br>$$</p>
<p>$$<br>P(s1,s2…st)=\prod_{t}P(St|St-1)<br>$$</p>
<p>把这两条公式代入（5.5），就可以得到（5.6）。至于找出上述式子的最大值，可以用维特比算法。</p>
<h2 id="模型的训练"><a href="#模型的训练" class="headerlink" title="模型的训练"></a>模型的训练</h2><p>如何根据观测数据，得到隐含马尔可夫模型的参数?根据条件概率的定义<br>$$<br>P(Ot|St)=\frac{P(Ot,St)}{P(St)}<br>$$</p>
<p>$$<br>P(St|St-1)=\frac{P(St,St-1)}{P(St-1)}<br>$$</p>
<p>利用人工标注的数据，可以直接得到状态St出现的次数等等，这种方法叫做有监督的训练方法。人工基本做不到。</p>
<p>直接通过大量观测到的信号就能推算出参数的方法，称为无监督的训练方法。其中主要使用鲍姆韦尔奇算法。首先找到一组能够产生输出序列的模型参数，得到一个初始模型$$M_{\theta0}$$，可以算出这个模型产生O的概率P(O|$$M_{\theta0}$$)，以及产生O的所有可能的路径和这些路径的概率。然后计算另一个模型的参数<br>$$<br>P(O|M_{\theta1})&gt;P(O|M_{\theta0})<br>$$<br>不断迭代就能找出最好的模型。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>数学之美</tag>
      </tags>
  </entry>
</search>
